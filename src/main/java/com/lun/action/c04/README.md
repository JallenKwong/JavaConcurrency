# 锁的优化及注意事项 #

## 有助于提高“锁”性能的几点建议 ##

### 减少锁持有时间 ###

	public synchronized void syncMethod(){
		othercode1();
		mutexMethod();
		othercode2();
	}

转变成

	public void syncMethod(){
		othercode1();
		synchronized(this){
			mutexMethod();
		}
		othercode2();
	}

### 减少锁粒度 ###

这种技术典型的使用场景就是ConcurrentHashMap类的实现。

对于HashMap来说，最重要的两方法get()、put()。一种最自然的想法就是对整个HashMap加锁，必然可以得到一个线程安全的对象。但是，这样做的话被认为加大锁粒度。

对于ConcurrentHashMap，它内部进一步细分了若干个小的HashMap，称之为段Segment。

如果需要在ConcurrentHashMap中增加一个新的表项，并不是件整个HashMap加锁，而是首先根据hashcode得到该表项应该被存放到哪个段中，然后对该段加锁，并完成put()操作。在多线程环境下，若多个线程同时进行put()操作，只要被加入的表项不存放在同一段中，则线程间便可以做到真正的并行。

### 读写分离锁来替换独占锁 ###

ReadWriteLock可以提高系统的性能。使用读写分离锁来替代独占锁是减少锁粒度的一种特殊情况。

### 锁分离 ###

一个典型的案例就是java.util.concurrent.LinkedBlockingQueue的实现。

它定义了takeLock和putLock，它们分别take()和put()操作中使用。因此，take()和put()就吃相互独立，它们之间不存在锁竞争关系，只需要在take()和take()、put()和put()间分别对takeLock和putLock进行竞争。从而，削弱锁竞争的可能性。

### 锁粗化 ###

VM在遇到一连串连续地对同一锁不断进行请求和释放的操作是，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，这个操作叫做锁的粗化。

	public void demoMethod(){
	
		synchronized(lock){
			//do sth
		}
	
		//做其它不需要的同步工作，但能很快执行完毕
	
		synchronized(lock){
			//do sth
		}
	
	}

会被整合成

	public void demoMethod(){
	
		synchronized(lock){

			//do sth

			//做其它不需要的同步工作，但能很快执行完毕

			//do sth
		}
	
	}

---

	for(int i = 0; i < circle; i++){
		synchronized(lock){
	
		}
	}

更合理做法是在外层只请求一次锁：

	synchronized(lock){
		for(int i = 0; i < circle; i++){

		}
	}

性能优化就是根据运行时的真实情况对各种资源点进行权衡折中的过程。锁粗化的思想和减少锁持有时间是相反的，但在不同的场合，它们的效果并不相同。所以需根据实际情况，进行权衡。

## JVM对锁优化所做的努力 ##

### 锁偏向 ###

它的核心思想是：如果一个线程获得了锁，那么锁就进入**偏向模式**。当这个线程再次请求锁时，无须再做任何同步操作。这样就节省了大量有关锁申请的操作，从而提高了程序性能。

因此对于几乎没有锁竞争的场合，偏向锁有比较好的优化效果，因为连续多次极有可能是同一个线程请求相同的锁。

而对于锁竞争比较激烈的场合，其效果不佳。因为在竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁。

这样偏向模式会失效，因此还不如不启用偏向锁。使用Java虚拟机参数-XX:UseBiasedLocking


### 轻量级锁 ###

若偏向锁失败，VM并不会立即挂起线程。它会使用一种称为轻量级锁的优化手段。轻量级锁的操作也很轻便，它只是简单地将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。

若对象线程获得轻量级锁成功，则可以顺利进入临界区。

若轻量级锁加锁失败，则表示其他线程抢先争夺到锁，那当前线程的锁请求就会膨胀为重量级锁。

### 自旋锁 ###

锁膨胀后，虚拟机为了避免真实地在操作系统层面挂起，虚拟机会在最后的努力——自旋锁。由于当前线程暂时无法获得锁，但是什么时候可以获得锁时一个未知数。也许在几个CPU周期后，就可以得到锁。如果这样，简单粗暴地挂起线程可能是一种得不偿失的操作。

因此，系统会进行一次赌注：它会假设在不久的将来，线程可以得到这把锁。因此，虚拟机会让当前线程做几个空循环（这也是自旋的含义），在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能获得锁，才会真实地将线程在操作系统层面挂起。

### 锁消除 ###

JVM在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争锁。通过锁消除，可以节省毫无意义的请求锁时间。

锁消除涉及一项关键技术为**逃逸分析**。逃逸分析就是观察某一个变量是否会逃出某一个作用域。

逃逸分析必须在-server模式下进行，可以使用-XX:+DoEscapeAnalysis参数打开逃逸分析。使用-XX:+EliminateLocks参数可以打开锁消除。

## 人手一支笔：ThreadLocal ##
